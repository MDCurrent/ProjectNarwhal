const path = require('path');
const ts = require('typescript');
const semver = require('semver');
const slashes = require('slashes');
const debug = require('debug')('angular-ide');
const chalk = require('chalk');

const ngCLIPKG = getNGCLIManifest();

const ngCLIPKGName = ngCLIPKG.name;
const ngCLIPath = getNGCLIPath(ngCLIPKGName);

const CLEnablementStatusManager = require('./CLEnablementStatusManager').CLEnablementStatusManager;
const CLBootstrapInjectorPlugin = require('./CLBootstrapInjectorPlugin');

function _getContentOfKeyLiteral(source, node) {
    if (node.kind == ts.SyntaxKind.Identifier) {
        return node.text;
    }
    else if (node.kind == ts.SyntaxKind.StringLiteral) {
        return node.text;
    }
    else {
        return null;
    }
}

function injectComponentMetadata_1() {
  let TypeScriptFileRefactor = null;
  try {
    TypeScriptFileRefactor = require('@ngtools/webpack/src/refactor');
  } catch(e) {
    TypeScriptFileRefactor = require('@angular/cli/node_modules/@ngtools/webpack/src/refactor');
    require.cache['@ngtools/webpack/src/refactor'] = require('@angular/cli/node_modules/@ngtools/webpack/src/refactor');
  }

  const origFun = TypeScriptFileRefactor.TypeScriptFileRefactor;

  TypeScriptFileRefactor.TypeScriptFileRefactor = function (fileName, _host, _program) {
    const origInstance = new (Function.prototype.bind.apply(origFun, [this, fileName, _host, _program]));

    const _self = origInstance;

    (function(c) {
      if (c) {
      const sourceFile = _self.sourceFile;

      const styleUrls = [];
      
      let templateUrl = null;

      // Find all object literals.
      _self.findAstNodes(sourceFile, ts.SyntaxKind.ObjectLiteralExpression, true)
        .map(function (node) { return _self.findAstNodes(node, ts.SyntaxKind.PropertyAssignment); })
        .reduce(function (prev, curr) { return curr ? prev.concat(curr) : prev; }, [])
        .filter(function (node) {
        const key = _getContentOfKeyLiteral(sourceFile, node.name);
        if (!key) {
            // key is an expression, can't do anything.
            return false;
        }
        return key == 'templateUrl' || key == 'styleUrls';
      })
          .forEach(function (node) {
          let key = _getContentOfKeyLiteral(sourceFile, node.name);
          if (key == 'templateUrl') {
            let templateUrlNode = _self.findAstNodes(node, ts.SyntaxKind.StringLiteral, false);
            templateUrl = path.normalize( path.join(
                path.dirname(sourceFile.fileName),
                templateUrlNode[0].text
              )
            );
          }
          else if (key == 'styleUrls') {
              const arr = (_self.findAstNodes(node, ts.SyntaxKind.ArrayLiteralExpression, false));

              arr.forEach( function (arrElement) {
                  const dirName = path.dirname(sourceFile.fileName);
                  let styleUrl = path.normalize(path.join(dirName, arrElement.elements[0].text));

                  styleUrls.push(styleUrl);               
              });

              if (!arr || arr.length == 0 || arr[0].elements.length == 0) {
                  return;
              }
              const initializer = arr[0].elements.map(function (element) {
                  return element.getFullText(sourceFile);
              });
          }
      });

      let isAComponent = false;
      if (sourceFile.identifiers) {
        if (typeof sourceFile.identifiers.Component !== 'undefined') {
          isAComponent = true;
        }
        if (!isAComponent && typeof sourceFile.identifiers.get === 'function') {
          isAComponent = sourceFile.identifiers.get('Component')
        }
      }

      if (isAComponent) {
          _self.findAstNodes(sourceFile, ts.SyntaxKind.ClassDeclaration, true)
              .forEach (function (node ) {
                  let tsPath = path.normalize(sourceFile.fileName);

                  const metadataToInject = {
                      componentPath: tsPath,
                      styleUrls: styleUrls,
                      templateUrl: templateUrl,
                  };

                  const textToInject = `__clMeta = ${JSON.stringify(metadataToInject)};`;

                  _self.insertAt(node.members.pos, textToInject);
              });
      }
    }
    })(CLEnablementStatusManager.getStatus());
    

    return _self;
  };

  TypeScriptFileRefactor.TypeScriptFileRefactor.prototype = origFun.prototype;

  TypeScriptFileRefactor.TypeScriptFileRefactor.prototype.insertAt = function (pos, text) {
    if (this._sourceString.prependRight) {
      //get rid of warning logged during build
      this._sourceString.prependRight(pos, text);
    } else {
      this._sourceString.insertRight(pos, text);
    }
    this._changed = true;
  };
}

function injectComponentMetadata_2() {
  const NgCliWebpackConfig = require(`${ngCLIPath}/models/webpack-config`).NgCliWebpackConfig;
  
  NgCliWebpackConfig.prototype.originalGetTargetConfig = NgCliWebpackConfig.prototype.getTargetConfig;

  NgCliWebpackConfig.prototype.getTargetConfig = function monkeyPatchedGenerateConfig(projectRoot, appConfig) {
    const targetConfig = this.originalGetTargetConfig(projectRoot, appConfig);

    if (typeof targetConfig.module === 'undefined') {
      targetConfig.module = { rules: [] };
    }

    if (typeof targetConfig.module.rules === 'undefined') {
      targetConfig.module.rules = [];
    }

    targetConfig.module.rules.push({ enforce: 'pre', test: /\.(ts)$/, loader: 'angular-ide-loader'});

    return targetConfig;
  };
}

function injectCLBootstrapScript_1(ngCLIVersion, config) {
  const NgCliWebpackConfig = require(`${ngCLIPath}/models/webpack-config`).NgCliWebpackConfig;
  
  NgCliWebpackConfig.prototype.originalGetTargetConfig1 = NgCliWebpackConfig.prototype.getTargetConfig;

  NgCliWebpackConfig.prototype.getTargetConfig = function monkeyPatchedGenerateConfig(projectRoot, appConfig) {
    const targetConfig = this.originalGetTargetConfig1(projectRoot, appConfig);

    if (typeof targetConfig.module === 'undefined') {
      targetConfig.module = { rules: [] };
    }

    if (typeof targetConfig.module.rules === 'undefined') {
      targetConfig.module.rules = [];
    }

    targetConfig.module.rules.push({ test: /\.(html)$/, loader: 'angular-ide-loader', options: config });

    return targetConfig;
  };
}

function injectCLBootstrapScript_2(ngCLIVersion, config) {
  const NgCliWebpackConfig = require(`${ngCLIPath}/models/webpack-config`).NgCliWebpackConfig;
  
  NgCliWebpackConfig.prototype.originalGetTargetConfig = NgCliWebpackConfig.prototype.getTargetConfig;

  NgCliWebpackConfig.prototype.getTargetConfig = function monkeyPatchedGenerateConfig(projectRoot, appConfig) {
    const targetConfig = this.originalGetTargetConfig(projectRoot, appConfig);

    (function() {
        if (typeof targetConfig.plugins === 'undefined') {
          targetConfig.plugins = [];
        }

        targetConfig.plugins.push(new CLBootstrapInjectorPlugin(config));
    })();

    return targetConfig;
  };
}

function injectComponentMetadata(ngCLIVersion) {

  if (semver.satisfies(ngCLIVersion, '>=1.0.0-beta.16 <1.0.0-beta.22')) {
    injectComponentMetadata_2();
    return;
  }
 
  injectComponentMetadata_1();
}

function injectCLBootstrapScript(ngCLIVersion, config) {
  if (semver.satisfies(ngCLIVersion, '>=1.0.0-beta.16 <1.0.0-beta.25')) {
    injectCLBootstrapScript_1(ngCLIVersion, config);
    return;
  }
  
  injectCLBootstrapScript_2(ngCLIVersion, config);
}

function normalizePackageVersion(packageVersion) {
  const prereleaseParts = semver.prerelease(packageVersion);
  if (prereleaseParts &&
    prereleaseParts.length > 1 &&
    typeof prereleaseParts[1] === 'string'
  ) {
    packageVersion = packageVersion.replace(`${prereleaseParts[0]}.${prereleaseParts[1]}`,
      `${prereleaseParts[0]}.${parseInt(prereleaseParts[1])}`
    );
  }

  return packageVersion;
}

function getNGCLIManifest() {
  let manifest = null;
  try {
    manifest = require('../../@angular/cli/package.json')
  } catch (e) {
    debug('Unable to detect package using new name, trying with old name');
  }

  if (manifest === null) {
    try {
      manifest = require('../../angular-cli/package.json');
    } catch (e) {
      debug(chalk.red('Unable to detect package using old name'));
    }
  }

  return manifest;  
}

function getNGCLIPath(packageName) {
  let rootPath = null;

  switch(packageName) {
    case 'angular-cli':
      rootPath = 'angular-cli';
      break;
    case '@angular/cli':
      rootPath = '@angular/cli';
      break;
    default:
  }

  return rootPath;
}

module.exports.injectComponentMetadata = injectComponentMetadata;
module.exports.injectCLBootstrapScript = injectCLBootstrapScript;
module.exports.normalizePackageVersion = normalizePackageVersion;
module.exports.getNGCLIManifest = getNGCLIManifest;
module.exports.getNGCLIPath = getNGCLIPath;
